# docker1
Docker

**Docker** – стандартизированное ПО для управления контейнерами и образами, которое является оберткой над встроенными в ядро линукс подсистемами cgroups и namespaces. Они отвечают за контроль над выделением и потреблением ресурсов, а также изоляцию процессов с помощью пространств имён.

**Docker Amazon** – это программная платформа для быстрой разработки, тестирования и развертывания приложений. Docker упаковывает ПО в стандартизованные блоки, которые называются контейнерами. Каждый контейнер включает все необходимое для работы приложения: библиотеки, системные инструменты, код и среду исполнения. Благодаря Docker можно быстро развертывать и масштабировать приложения в любой среде и сохранять уверенность в том, что код будет работать.

**Основное назначение Docker**
- решает проблему с окружением, необходимым для работы приложения;
- исключает необходимость воссоздания окружения при переносе приложения с одного сервера на другой;
- запускает специальные образы, из которых вырезано почти все, что не требуется для работы приложения

**Принципиальная схема**
- Клиент через какой-либо интерфейс отправляет команды хосту, на котором стоит Docker демон;
- Демон, получая команды, запускает или останавливает Docker контейнеры из Docker Image;
- Docker Image в свою очередь скачивается или заливается в реестр;
- Реестр может быть частным или поддерживаемым разработчиками (Docker Hub);
- Также Docker Image может быть создан из Dockerfile.

В Docker ещё до создания Docker Image, есть DockerFile. Это инструкции, используемые для генерации Docker Image.

**Dockerfile** — это конфигурационный файл, в котором описаны инструкции, которые будут применены при сборке Docker-образа и запуске контейнера. Dockerfile создается в корневой директории проекта и не имеет расширения.

https://habr.com/ru/companies/ruvds/articles/439980/

- FROM — задаёт базовый (родительский) образ.
- LABEL — описывает метаданные. Например — сведения о том, кто создал и поддерживает образ.
- ENV — устанавливает постоянные переменные среды.
- RUN — выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов.
- COPY — копирует в контейнер файлы и папки.
- ADD — копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы.
- CMD — описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция CMD.
- WORKDIR — задаёт рабочую директорию для следующей инструкции.
- ARG — задаёт переменные для передачи Docker во время сборки образа.
- ENTRYPOINT — предоставляет команду с аргументами для вызова во время выполнения контейнера. Аргументы не переопределяются.
- EXPOSE — указывает на необходимость открыть порт.
- VOLUME — создаёт точку монтирования для работы с постоянным хранилищем.

Docker Hub хранит в себе превеликое множество готовых Docker Image. Но когда нужно сделать что-то свое, мы прибегаем к Dockerfile. Вместо того, чтобы каждый раз производить настройку вручную, мы один раз пишем сценарий этой настройки. Указывая все, что Docker необходимо сделать, чтобы на выходе получить единственно верный Docker Image

```
# Используем как основу последний образ Debian
FROM debian:latest
# Указываем создателя имиджа
MAINTAINER Test Netology
# Указываем версию
LABEL version="1.0"
# Указываем команду которая будет выполнена при сборке контейнера
RUN DEBIAN_FRONTEND="noninteractive" apt install -y tzdata && apt update && apt install -y apache2 nano
# Копируем файл внутрь нашего контейнера
COPY ./index.html /var/www/html/index.html
# Включаем возможность прокидывать трафик на 80й TCP порт (Команда EXPOSE не прокидывает трафик с хоста в контейнер, а только говоритчто мы можем так делать.)
EXPOSE 80/tcp
# Запускаем апач
CMD apachectl -D FOREGROUND
```
Чтобы собрать из этого файла пригодный для работы образ, используем команду:
```
docker build -t netologytest1:1.1 .
```
После сборки найдем ID собранного контейнера с помощью команды:
```
docker image ls
```
Запустим только что созданный образ с помощью команды:
```
docker run -d -p 80:80 id_созданного_образа
```
Параметр -p говорит Docker Engine, что мы хотим с порта 80 Docker сервера, прокинуть трафик на порт 80 контейнера

Давайте посмотрим на содержимое любого созданного намиобраза. Для этого нужна команда:
```
docker image history id_образа
```
Мы увидим упорядоченные «слои», из которых состоит наш образ.

Docker слои
- Слои позволяют не создавать каждый раз весь образ целиком, а пересоздавать только слой, относящийся к команде, которую мы изменили, и все идущие следом за ним;
- Слои можно рассматривать как «коммиты» в репозитории. Они описывают процесс поэтапной модификации образа, вследствие которой он пришёл к своему текущему состоянию.
- Мы можем взять любой готовый образ и использовать его, указав в строке FROM нашего Dockerfile. Тогда, не внося изменений в базовый образ, Docker поэтапно наложит все наши модификации на него при создании нового образа.

- Подход, основанный на наложении слоев, позволяет не тратить время на повторную сборку слоев, которые не были затронуты очередным изменением.
- Если же попытаться повторно собрать образ из Dockerfile, в который не было внесено каких-либо изменений, сборка произойдет почти моментально.

**Docker Image** – это стандартизированный образ.

**Docker Container** – запущенный Image
- Опять же по аналогии, если Docker Image – это кассета, которую можно вставить в магнитофон.
- То Docker Container – это вставленная в магнитофон и играющаякассета.
- 10 раз запустив один Docker Image – мы создадим 10 одинаковых Docker контейнеров.

Любой контейнер изолирован от других контейнеров и от хоста, на котором он запущен. Никакое действие или бездействие внутри контейнера не повлияют на другие контейнеры или Docker сервер. Можно удалить, например, пакет php7 из одного контейнера, но это никак не повлияет на другие контейнеры, в которых этот пакет стоит.

**Docker Hub** - Публичное облачное хранилище, куда можно загрузить свои Docker Image для последующей работы с ними. Поддерживается самими разработчиками Docker. Репозиторий в Docker Hub может быть как публичным, так и приватным.

Устанавливаем пакеты для работы apt через HTTPS
**Обновляем кеш**
```
sudo apt update
```
**Устанавливаем необходимые пакеты**
```
sudo apt install apt-transport-https ca-certificates curl gnupg lsb-release
```
**Добавляем GPG ключ**
```
curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
```
**Добавляем stable репозиторий для x86_64 / amd64**
```
echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
```
**Устанавливаем Docker Engine**
```
sudo apt update
sudo apt install docker-ce docker-ce-cli containerd.io
```
**Запускаем Docker**
```
sudo systemctl enable docker
sudo systemctl start docker
```
Первое, с чего можно начать – это Hello World. Для этого используем следующую команду для запуска образа hello-world:
```
docker run hello-world
```
Docker, не обнаружив образ hello-world локально, подключится к Docker Hub, скачает его и запустит контейнер.

Например, если свой контейнер вы взяли из репозитория, hello-world, то при выходе обновления вам понадобится команда pull.
```
docker pull hello-world
```
По аналогии с командой ls (которая отображает содержимое каталога), чтобы посмотреть хранимые локально Docker Images, можно использовать следующую команду:
```
docker images
```
Результат будет представлен в виде текстовой таблицы

Узнать список работающих контейнеров можно командой:
```
docker container ls
```
Узнав ID контейнера, можно посмотреть его логи с помощью команды:
```
docker logs id_контейнера
```
Смотрим список Docker Container’ов
- CONTAINER ID – Идентификатор контейнера,
- IMAGE – Образ, использованный при создании контейнера,
- COMMAND – Запущенная команда,
- CREATED – Время, прошедшее с момента запуска,
- STATUS – Статус контейнера, работает ли или завершил работу,
- PORTS – Проброшенные в контейнер порты,
- NAMES – Случайно сгенерированное имя

**Docker run VS Docker start**

Важно упомянуть про разницу между run и start
```
docker run имя_образа
```
Находит\скачивает Image, создает из него контейнер и стартует созданный контейнер. 10 раз запустив эту команду с именем какого-то образа, вы создадите 10 контейнеров.
```
docker start id_контейнера (или его имя)
```
Запускает уже существующий, но остановленный контейнер. Таким образом, вы можете запустить контейнер, произвести в нем какие-то настройки, остановить с помощью команды docker stop и потом запустить, не потеряв произведенные настройки.

**Удаляем лишние образы**
Если необходимо удалить какой-либо образ, чтобы освободить место, необходимо сперва удалить все созданные на его основе контейнеры. Удалим, к примеру, hello-world.

Сначала смотрим имеющиеся контейнеры:
```
docker container ls -a
```
Когда все контейнеры, использующие образ удалены, можно удалить сам образ
```
docker container rm id\имя_контейнера
```
Смотрим на id или имена и с их помощью удаляем контейнеры:
```
docker image rm hello-world
```

Общая схема команд для управления контейнерами выглядит так:
```
docker container my_command
```
Вот команды, которые могут быть подставлены туда, где мы использовали my_command:
- create — создание контейнера из образа. https://docs.docker.com/engine/reference/commandline/container_create/
- start — запуск существующего контейнера.
- run — создание контейнера и его запуск. https://docs.docker.com/engine/reference/commandline/container_run/
```
docker container run -i -t -p 1000:8000 --rm my_image
docker container run -it my_image my_command
docker container run -d my_image - -d — это сокращение для --detach. Эта команда запускает контейнер в фоновом режиме.
```
- ls — вывод списка работающих контейнеров.
- inspect — вывод подробной информации о контейнере.
- logs — вывод логов.
- stop — остановка работающего контейнера с отправкой главному процессу контейнера сигнала SIGTERM, и, через некоторое время, SIGKILL. У контейнера есть, по умолчанию, 10 секунд, на то, чтобы завершить работу.
- kill — остановка работающего контейнера с отправкой главному процессу контейнера сигнала SIGKILL.
```
docker container kill $(docker ps -q) - команда, которая позволяет быстро остановить все работающие контейнеры
```
- rm — удаление остановленного контейнера.
```
docker container rm $(docker ps -a -q) - команда, которая позволяет удалить все контейнеры, которые на момент вызова этой команды не выполняются
```
Команды для управления образами

Для управления образами используются команды, которые выглядят так:
```
docker image my_command
```
Вот некоторые из команд этой группы:
- build — сборка образа.
- push — отправка образа в удалённый реестр.
- ls — вывод списка образов.
- history — вывод сведений о слоях образа.
- inspect — вывод подробной информации об образе, в том числе — сведений о слоях.
- rm — удаление образа.

Разные команды

- docker version — вывод сведений о версиях клиента и сервера Docker.
- docker login — вход в реестр Docker.
- docker system prune — удаление неиспользуемых контейнеров, сетей и образов, которым не назначено имя и тег.

Docker
- run - запускает контейнер
- pull - команда закачивает образ из репозитория на наш компьютер. run вызывает эту функцию, если контейнер не скачан.
- ps - просмотр запущенных контейнеров
- rm - удаление контейнера. Не образа, а именно контейнера
- stop - остановить запущенный контейнер
- start - запустить остановленный контейнер
- exec - выполнить команду в запущенном контейнере
- cp - копирование файлов между контейнером и хост-системой.
- info - информация о состоянии и конфигурации контейнера
- logs - логи контейнера
- attach - зацепиться в консоль контейнера
- search - поиск образа в репозитории
